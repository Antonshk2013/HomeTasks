# 01. Для заданного целого числа N подсчитать количество положительных чётных чисел,
# меньше или равных N (не включая 0).

def count_numbers(n):
    n = abs(n)
    count = 0
    while n > 0:
        if n % 2 == 0:
            count += 1
        n -= 1
    else:
        return count


# 02. Вычислите n-е число ряда Фибоначчи с помощью цикла while.
# Числа Фибоначчи: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 34

def fibonacci(n):
    if n == 0:
        return "Error"
    a, b = 0, 1
    if n == 1:
        return a
    if n == 2:
        return b
    position = 2
    while position <= n:
        a, b = b, a + b
        position += 1
    else:
        return a

# 03. По данному натуральному числу N найдите наибольшую целую степень двойки,
# не превосходящую N.
# Выведите показатель степени и саму степень.

def find_degree(n):
    degree = 0
    while 2**(degree+1) <= n:
        degree += 1
    else:
        return f"{degree} {2**degree}"

# 04. Дано целое число, не меньшее 2.
#  Выведите его наименьший натуральный делитель, отличный от 1.

def smallest_natural_number(n: int):
    dec = n
    min_dec = n
    while dec > 1:
        if n % dec == 0:
            min_dec = dec
        dec -= 1
    else:
        return min_dec


# 05. Определите сумму всех элементов последовательности, завершающейся числом 0.
# Числа, следующие за первым нулём, учитывать не нужно.
# Числа считываем с клавиатуры с помощью input()
# (Проверку, является ли введённое значение числом, делать необязательно.)
#
#
# 06. Усложняем предыдущую задачу.
# Определите среднее значение всех элементов последовательности, завершающейся числом 0.
# Среднее значение - сумма всех элементов, поделенная на их количество.
#
#
# 07. Последовательность состоит из натуральных чисел и завершается числом 0.
# Определите значение наибольшего элемента последовательности.
#
#
# 08. Последовательность состоит из натуральных чисел и завершается числом 0.
# Определите индекс наибольшего элемента последовательности.
# Нумерация элементов начинается с нуля.
#
#
# 09. Дан объём шара X куб. ед. Найдите радиус фигуры.
#  V = 4 / 3 * pi * r ^ 3
#
#  r ^ 3 = 3 * V / 4 * pi
#
#  r = (3 * V / 4 * pi) ** 1/3
#
#
# 10. Пользователь вводит вещественное число и число знаков после запятой,
# до которого нам нужно его округлить это вещественное.
# Введённые значения и полученный результат вывести через пробел в одной строчке.
# Воспользуемся функцией round — встроенная функция Python.
# Ее задача — округлять число с плавающей точкой до той цифры, которую задаёт пользователь.
# Функция round помогает «улучшать» числа с плавающей точкой.
#
#  Пример:
#  3.1415926 3 -> 3.1415926 3 3.1455
#
#
#
# 11. Так как в Python операции с вещественными числами могут давать неожиданные результаты (
# в частности, 0.1 + 0.2 не будет в точности равняться 0.3), стоит задача с этим как-то справляться.
# Требуется написать функция eqv(a, b, c), которая принимает 3 числа. Числа a и b складываются.
# Затем эта сумма сравнивается с числом “с” с определенной степенью точности.
# Точность равняется 0.01 % от большего из чисел a и b.
# Функция вернет True, если выполняется равенство, иначе False.


if __name__ == '__main__':
    # print(count_numbers(6))
    # print(fibonacci(6))
    # print(find_degree(9))
    print(smallest_natural_number(17))
